#include "../../headers/Control/FieldParser.h"
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
Field ParseField(char *filepath, FieldProperties properties) {
    //expected input is the CSV generated by the python script. 

    FILE* file = fopen(filepath, "r");

    if(file == NULL) {
        printf("pain");
        fprintf(stderr, "Failed to open File");
        scanf("\n");
        exit(EXIT_FAILURE);
    }

    Field output;
    double Xstep = properties.Xstep;
    double Ystep = properties.Ystep;
    double Zstep = properties.Zstep;

    //preliminary readings
    output.startX = properties.XStart;
    output.steplengthX = Xstep;

    output.startY = properties.YStart;
    output.steplengthY = Ystep;
    
    output.startZ = properties.ZStart;
    output.steplengthZ = Zstep;

    //this could be updated to include 2D fields.
    if(Xstep == 0 || Ystep == 0 || Zstep == 0) {
        printf("xstep: %lf, ystep: %lf, zstep: %lf\n", Xstep, Ystep, Zstep);
        fprintf(stderr, "0 steplength for X, Y or Z is not allowed in this program, please use a valid 3D field\n");
        exit(EXIT_FAILURE);
    }

    //distrust of floating point inaccuracies.
    int xsize = (int)(((properties.Xend-properties.XStart)/Xstep)+2);
    int ysize = (int)(((properties.Yend-properties.YStart)/Ystep)+2);
    int zsize =(int)(((properties.Zend-properties.ZStart)/Zstep)+2);

    //initialise arrays based on (hopefully good) size estimates.
    //the floating poitns here are a headache
    output.FieldValues = calloc(sizeof(Vector**), xsize);
    for (int i = 0; i< xsize; i++) {
        output.FieldValues[i] = calloc(sizeof(Vector*), ysize);
        for (int j = 0; j< ysize; j++) {
            output.FieldValues[i][j] = calloc(sizeof(Vector), zsize);
        }
    }

    int check; //for EOF check
    //preliminary declarations for the loop
    double currentZ, vecZ;
    double currentY, vecY;
    double currentX, vecX;
    double newZ = properties.ZStart;
    double newY = properties.YStart;
    double newX = properties.XStart;
    int xindex = 0;
    int yindex = 0;
    int zindex = 0;

    output.lengthX = xsize-1;
    output.lengthY = ysize-1;
    output.lengthZ = zsize-1;

    if(feof(file)) {
        fprintf(stderr, "Error: Empty file in the parser");
        exit(EXIT_FAILURE);
    }
    check = fscanf(file, "%lf,%lf,%lf,%lf,%lf,%lf\n", &newX, &newY, &newZ, &(vecX), &(vecY), &(vecZ));
    if (check < 6) fprintf(stderr, "Warning, failed to read %d values at X: %d, Y: %d, Z: %d \n", (6-check), xindex, yindex, zindex);


    //the function is quite verbose: each read is accompanied with an EOF check for ungraceful exits, no error handling is implemented, imperfect reads are carried on.
    do {
        do {
            do {
                Vector newVec;
                currentX = newX; 
                currentY = newY; 
                currentZ = newZ; 

                newVec.x = vecX;
                newVec.y = vecY;
                newVec.z = vecZ;

                //size checks
                //this *should* only happen once at most, but floating points are not to be trusted.
                if(xindex >= xsize) {
                    printf("resize");
                    int newXsize = xsize+100;
                    output.FieldValues = realloc(output.FieldValues, sizeof(Vector**)*newXsize);
                    for (int i = xsize; i<newXsize; i++) {
                        output.FieldValues[i] = calloc(sizeof(Vector*), ysize);
                        for (int j = 0; j< ysize; j++) {
                            output.FieldValues[i][j] = calloc(sizeof(Vector), zsize);
                        }
                    }
                    xsize = newXsize;
                }
                if(output.lengthX <= xindex) {
                    output.lengthX = xindex+1;
                }
                output.FieldValues[xindex][yindex][zindex] = newVec;
                xindex++;

                //if there is a graceful break, it is here.
                if (feof(file)) {
                    break;
                }
                check = fscanf(file, "%lf,%lf,%lf,%lf,%lf,%lf\n", &newX, &newY, &newZ, &(vecX), &(vecY), &(vecZ)); // read line
                if (check < 6) fprintf(stderr, "Warning, failed to read %d values at X: %d, Y: %d, Z: %d \n", (6-check), xindex, yindex, zindex);

            } while ((Xstep < 0 && newX < (currentX - (Xstep/2))) || (Xstep > 0 && newX > (currentX - (Xstep/2))));
            //for exit.
            if(feof(file)) break;
            
            //size checks
            if(yindex > ysize) {
                printf("resize(y)");
                ysize += 100;
                output.FieldValues[xindex] = realloc(output.FieldValues[xindex], sizeof(Vector*)*xsize);
            }
            if(output.lengthY <= yindex) {
                output.lengthY = yindex+1;
            }
            yindex++;
            xindex = 0;
        } while ((Ystep < 0 && newY < (currentY - (Ystep/2))) || (Ystep > 0 && newY > (currentY - (Ystep/2))));
    
        if(zindex>zsize) {
            printf("resize(z)");
            zsize +=100;
            output.FieldValues[xindex][yindex] = realloc(output.FieldValues[xindex][yindex], sizeof(Vector)*zsize);
        }
        if(output.lengthZ <= yindex) {
            output.lengthZ = zindex +1;
        }
        yindex = 0;
        zindex++;
    } while (!feof(file));

    fclose(file);
    return output;
}